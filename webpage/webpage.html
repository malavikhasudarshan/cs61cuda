<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CS61Cuda Project: Matmul &amp; CUDA Fundamentals</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="floating quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#learning-goals" id="toc-learning-goals" class="nav-link active" data-scroll-target="#learning-goals"><span class="header-section-number">1</span> Learning Goals</a></li>
  <li><a href="#repo-layout-what-you-edit" id="toc-repo-layout-what-you-edit" class="nav-link" data-scroll-target="#repo-layout-what-you-edit"><span class="header-section-number">2</span> Repo Layout &amp; What You Edit</a></li>
  <li><a href="#grading-summary" id="toc-grading-summary" class="nav-link" data-scroll-target="#grading-summary"><span class="header-section-number">3</span> Grading Summary</a></li>
  <li><a href="#cuda-primer-read-first" id="toc-cuda-primer-read-first" class="nav-link" data-scroll-target="#cuda-primer-read-first"><span class="header-section-number">4</span> CUDA Primer (read first)</a>
  <ul class="collapse">
  <li><a href="#core-concepts" id="toc-core-concepts" class="nav-link" data-scroll-target="#core-concepts"><span class="header-section-number">4.1</span> Core Concepts</a></li>
  <li><a href="#memory-hierarchy" id="toc-memory-hierarchy" class="nav-link" data-scroll-target="#memory-hierarchy"><span class="header-section-number">4.2</span> Memory Hierarchy</a></li>
  <li><a href="#performance-concepts" id="toc-performance-concepts" class="nav-link" data-scroll-target="#performance-concepts"><span class="header-section-number">4.3</span> Performance Concepts</a></li>
  <li><a href="#common-patterns-best-practices" id="toc-common-patterns-best-practices" class="nav-link" data-scroll-target="#common-patterns-best-practices"><span class="header-section-number">4.4</span> Common Patterns &amp; Best Practices</a></li>
  <li><a href="#common-pitfalls" id="toc-common-pitfalls" class="nav-link" data-scroll-target="#common-pitfalls"><span class="header-section-number">4.5</span> Common Pitfalls</a></li>
  <li><a href="#debugging-tips" id="toc-debugging-tips" class="nav-link" data-scroll-target="#debugging-tips"><span class="header-section-number">4.6</span> Debugging Tips</a></li>
  <li><a href="#cuda-documentation-finding-functions" id="toc-cuda-documentation-finding-functions" class="nav-link" data-scroll-target="#cuda-documentation-finding-functions"><span class="header-section-number">4.7</span> CUDA Documentation &amp; Finding Functions</a></li>
  <li><a href="#quick-reference" id="toc-quick-reference" class="nav-link" data-scroll-target="#quick-reference"><span class="header-section-number">4.8</span> Quick Reference</a></li>
  </ul></li>
  <li><a href="#task-1-welcome-to-61cuda-2d-copy-kernel-10-pts" id="toc-task-1-welcome-to-61cuda-2d-copy-kernel-10-pts" class="nav-link" data-scroll-target="#task-1-welcome-to-61cuda-2d-copy-kernel-10-pts"><span class="header-section-number">5</span> Task 1 — Welcome to 61Cuda: 2D Copy Kernel (10 pts)</a>
  <ul class="collapse">
  <li><a href="#conceptual-overview" id="toc-conceptual-overview" class="nav-link" data-scroll-target="#conceptual-overview"><span class="header-section-number">5.1</span> Conceptual Overview</a></li>
  <li><a href="#data-flow" id="toc-data-flow" class="nav-link" data-scroll-target="#data-flow"><span class="header-section-number">5.2</span> Data Flow</a></li>
  <li><a href="#your-task" id="toc-your-task" class="nav-link" data-scroll-target="#your-task"><span class="header-section-number">5.3</span> Your Task</a></li>
  </ul></li>
  <li><a href="#task-2-cpu-baseline-matmul-15-pts" id="toc-task-2-cpu-baseline-matmul-15-pts" class="nav-link" data-scroll-target="#task-2-cpu-baseline-matmul-15-pts"><span class="header-section-number">6</span> Task 2 — CPU Baseline Matmul (15 pts)</a>
  <ul class="collapse">
  <li><a href="#conceptual-overview-1" id="toc-conceptual-overview-1" class="nav-link" data-scroll-target="#conceptual-overview-1"><span class="header-section-number">6.1</span> Conceptual Overview</a></li>
  <li><a href="#data-flow-1" id="toc-data-flow-1" class="nav-link" data-scroll-target="#data-flow-1"><span class="header-section-number">6.2</span> Data Flow</a></li>
  <li><a href="#your-task-1" id="toc-your-task-1" class="nav-link" data-scroll-target="#your-task-1"><span class="header-section-number">6.3</span> Your Task</a></li>
  </ul></li>
  <li><a href="#task-3-cuda-naive-matmul-30-pts" id="toc-task-3-cuda-naive-matmul-30-pts" class="nav-link" data-scroll-target="#task-3-cuda-naive-matmul-30-pts"><span class="header-section-number">7</span> Task 3 — CUDA Naive Matmul (30 pts)</a>
  <ul class="collapse">
  <li><a href="#conceptual-overview-2" id="toc-conceptual-overview-2" class="nav-link" data-scroll-target="#conceptual-overview-2"><span class="header-section-number">7.1</span> Conceptual Overview</a></li>
  <li><a href="#data-flow-2" id="toc-data-flow-2" class="nav-link" data-scroll-target="#data-flow-2"><span class="header-section-number">7.2</span> Data Flow</a></li>
  <li><a href="#your-task-2" id="toc-your-task-2" class="nav-link" data-scroll-target="#your-task-2"><span class="header-section-number">7.3</span> Your Task</a></li>
  </ul></li>
  <li><a href="#task-4-cuda-simd-matmul-vectorized-no-shared-memory-30-pts" id="toc-task-4-cuda-simd-matmul-vectorized-no-shared-memory-30-pts" class="nav-link" data-scroll-target="#task-4-cuda-simd-matmul-vectorized-no-shared-memory-30-pts"><span class="header-section-number">8</span> Task 4 — CUDA SIMD Matmul (Vectorized, No Shared Memory) (30 pts)</a>
  <ul class="collapse">
  <li><a href="#conceptual-overview-3" id="toc-conceptual-overview-3" class="nav-link" data-scroll-target="#conceptual-overview-3"><span class="header-section-number">8.1</span> Conceptual Overview</a></li>
  <li><a href="#data-flow-3" id="toc-data-flow-3" class="nav-link" data-scroll-target="#data-flow-3"><span class="header-section-number">8.2</span> Data Flow</a></li>
  <li><a href="#your-task-3" id="toc-your-task-3" class="nav-link" data-scroll-target="#your-task-3"><span class="header-section-number">8.3</span> Your Task</a></li>
  </ul></li>
  <li><a href="#task-5-optional-performance-engineering-15-ec" id="toc-task-5-optional-performance-engineering-15-ec" class="nav-link" data-scroll-target="#task-5-optional-performance-engineering-15-ec"><span class="header-section-number">9</span> Task 5 — (Optional) Performance Engineering (15 EC)</a>
  <ul class="collapse">
  <li><a href="#performance-targets-grading" id="toc-performance-targets-grading" class="nav-link" data-scroll-target="#performance-targets-grading"><span class="header-section-number">9.1</span> Performance Targets &amp; Grading</a></li>
  </ul></li>
  <li><a href="#correctness-floatingpoint-notes" id="toc-correctness-floatingpoint-notes" class="nav-link" data-scroll-target="#correctness-floatingpoint-notes"><span class="header-section-number">10</span> Correctness &amp; Floating‑Point Notes</a></li>
  <li><a href="#debugging-checklist" id="toc-debugging-checklist" class="nav-link" data-scroll-target="#debugging-checklist"><span class="header-section-number">11</span> Debugging Checklist</a></li>
  <li><a href="#style-submission" id="toc-style-submission" class="nav-link" data-scroll-target="#style-submission"><span class="header-section-number">12</span> Style &amp; Submission</a>
  <ul class="collapse">
  <li><a href="#reflection-graded-in-task-5-rubric-even-if-you-skip-perf-ec" id="toc-reflection-graded-in-task-5-rubric-even-if-you-skip-perf-ec" class="nav-link" data-scroll-target="#reflection-graded-in-task-5-rubric-even-if-you-skip-perf-ec"><span class="header-section-number">12.1</span> Reflection (graded in Task 5 rubric even if you skip perf EC)</a></li>
  </ul></li>
  <li><a href="#reference-shapes-indexing" id="toc-reference-shapes-indexing" class="nav-link" data-scroll-target="#reference-shapes-indexing"><span class="header-section-number">13</span> Reference: Shapes &amp; Indexing</a></li>
  <li><a href="#rubric-details" id="toc-rubric-details" class="nav-link" data-scroll-target="#rubric-details"><span class="header-section-number">14</span> Rubric Details</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">CS61Cuda Project: Matmul &amp; CUDA Fundamentals</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Welcome to <strong>CS61Cuda!!</strong> This is a mini‑project that introduces you to GPU programming with CUDA by building up to a fast matrix multiply. You’ll start with a CPU reference, write your first CUDA kernels, learn to reason about grids/blocks/threads, and finally add simple vectorization (SIMD) on the GPU. An optional performance sandbox lets you explore optimizations for bragging rights.</p>
<section id="learning-goals" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="learning-goals"><span class="header-section-number">1</span> Learning Goals</h2>
<ul>
<li>Map data‑parallel work to CUDA’s <strong>grid/block/thread</strong> hierarchy.<br>
</li>
<li>Practice <strong>indexing</strong> and <strong>bounds checks</strong> in 1D/2D.<br>
</li>
<li>Understand <strong>memory access patterns</strong> (coalescing) and why they matter.<br>
</li>
<li>See the benefits of <strong>TLP</strong> (thread‑level parallelism) and <strong>DLP</strong> (data‑level/SIMD) on the GPU.<br>
</li>
<li>Read simple performance counters and reason about <strong>memory‑ vs compute‑bound</strong> kernels.</li>
</ul>
</section>
<section id="repo-layout-what-you-edit" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="repo-layout-what-you-edit"><span class="header-section-number">2</span> Repo Layout &amp; What You Edit</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>cs61cuda<span class="op">/</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>├─ CMakeLists<span class="op">.</span>txt # or Makefile <span class="op">(</span>both provided<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>├─ include<span class="op">/</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>│ └─ matmul<span class="op">.</span>h # shared function prototypes</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>├─ src<span class="op">/</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>│ ├─ main<span class="op">.</span>cpp # driver<span class="op">:</span> parses flags<span class="op">,</span> allocs<span class="op">,</span> calls your code</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>│ ├─ task_1_cuda_copy<span class="op">.</span>cu # ✏️ Task <span class="dv">1</span><span class="op">:</span> <span class="dv">2</span><span class="er">D</span> copy kernel</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>│ ├─ task_2_cpu_baseline<span class="op">.</span>cpp # ✏️ Task <span class="dv">2</span><span class="op">:</span> implement CPU matmul</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>│ ├─ task_3_cuda_naive<span class="op">.</span>cu # ✏️ Task <span class="dv">3</span><span class="op">:</span> naive CUDA matmul <span class="op">(</span><span class="dv">1</span> output<span class="op">/</span>thread<span class="op">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>│ ├─ task_4_cuda_simd<span class="op">.</span>cu # ✏️ Task <span class="dv">4</span><span class="op">:</span> vectorized CUDA matmul <span class="op">(</span>no shared mem<span class="op">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>│ ├─ utils<span class="op">.</span>cu # timers<span class="op">,</span> error checks<span class="op">,</span> random init<span class="op">,</span> compare</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>│ └─ check<span class="op">.</span>cuh # CUDA error macros <span class="op">(</span>provided<span class="op">)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>├─ tests<span class="op">/</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>│ ├─ correctness_tests<span class="op">.</span>py # local correctness checks</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>│ └─ perf_runner<span class="op">.</span>py # runs sizes <span class="op">&amp;</span> prints throughput</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>├─ data<span class="op">/</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>│ └─ generate<span class="op">.</span>py # makes small sample matrices <span class="op">(</span>optional<span class="op">)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>├─ scripts<span class="op">/</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>│ ├─ build<span class="op">.</span>sh # nvcc or cmake build helper</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>│ └─ run_all<span class="op">.</span>sh # runs all tasks <span class="op">&amp;</span> tests</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>└─ README<span class="op">.</span>md # quick overview</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>You will edit:</strong> <code>src/task_1_cpu_baseline.cpp</code>, <code>src/task_2_cuda_copy.cu</code>, <code>src/task_3_cuda_naive.cu</code>, <code>src/ctask_4_cuda_simd.cu</code>.</p>
</section>
<section id="grading-summary" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="grading-summary"><span class="header-section-number">3</span> Grading Summary</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 48%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Task</th>
<th>Description</th>
<th>Points</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Welcome to 61Cuda: Copy kernel (2D grid, indexing, bounds, coalescing)</td>
<td>10</td>
</tr>
<tr class="even">
<td>2</td>
<td>Baseline CPU matmul (triple-loop reference)</td>
<td>15</td>
</tr>
<tr class="odd">
<td>3</td>
<td>CUDA naive matmul (1 output/thread)</td>
<td>30</td>
</tr>
<tr class="even">
<td>4</td>
<td>CUDA <strong>SIMD</strong> matmul (vectorized loads, no shared memory)</td>
<td>30</td>
</tr>
<tr class="odd">
<td>5</td>
<td><strong>Performance engineering (optional)</strong></td>
<td>15 EC</td>
</tr>
</tbody>
</table>
<p><strong>Total:</strong> 100 required + 15 extra credit.</p>
<p><strong>Autograder policy.</strong> We check correctness on hidden sizes, run times on a standard GPU, and basic style (clear bounds checks, no UB). We do not require a specific speedup, but we verify your kernels scale sensibly with size.</p>
<p><strong>Collaboration.</strong> Discuss ideas high‑level with peers; code must be your own. Cite any online sources you consulted.</p>
</section>
<section id="cuda-primer-read-first" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="cuda-primer-read-first"><span class="header-section-number">4</span> CUDA Primer (read first)</h2>
<section id="core-concepts" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="core-concepts"><span class="header-section-number">4.1</span> Core Concepts</h3>
<ul>
<li>A <strong>kernel</strong> is a C/C++ function annotated <code>__global__</code> and launched with <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>.<br>
</li>
<li>Each launch creates a 2‑D/3‑D <strong>grid</strong> of <strong>blocks</strong>; each block contains many <strong>threads</strong>. Every thread runs the same kernel on different data.</li>
</ul>
<p><strong>Example:</strong> <code>myKernel&lt;&lt;&lt;dim3(2,2), dim3(16,16)&gt;&gt;&gt;(args)</code> creates a 2×2 grid of blocks, each with 16×16 threads (total: 4 blocks × 256 threads = 1024 threads).</p>
<ul>
<li>Built‑in variables inside kernels: <code>blockIdx.{x,y,z}</code>, <code>threadIdx.{x,y,z}</code>, <code>blockDim.{x,y,z}</code>, <code>gridDim.{x,y,z}</code>.</li>
</ul>
<p><strong>2D Indexing Example:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> blockDim<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span>  <span class="co">// row</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span>  <span class="co">// column</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Grid size calculation:</strong> When dimensions don’t divide evenly, round up:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>dim3 grid<span class="op">((</span>width <span class="op">+</span> block<span class="op">.</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> block<span class="op">.</span>x<span class="op">,</span> <span class="op">(</span>height <span class="op">+</span> block<span class="op">.</span>y <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> block<span class="op">.</span>y<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="memory-hierarchy" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="memory-hierarchy"><span class="header-section-number">4.2</span> Memory Hierarchy</h3>
<ul>
<li><strong>Global</strong> (device DRAM): large, high‑latency (~400-800 cycles); visible to all threads. Allocated with <code>cudaMalloc()</code>, accessed via pointers. Persists across kernel launches.</li>
<li><strong>Shared</strong> (on‑chip, per‑block): small (~48KB per SM), low‑latency (~20-30 cycles); visible to threads in the same block. Declared with <code>__shared__</code>. Cleared between kernel launches.</li>
<li><strong>Registers</strong> (per‑thread): fastest (~1 cycle), limited (~255 per thread). Automatic for local variables. Private to each thread.</li>
</ul>
<p><strong>Memory transfer patterns:</strong> * Host → Device: <code>cudaMemcpy(dst, src, size, cudaMemcpyHostToDevice)</code> * Device → Host: <code>cudaMemcpy(dst, src, size, cudaMemcpyDeviceToHost)</code> * Device → Device: <code>cudaMemcpy(dst, src, size, cudaMemcpyDeviceToDevice)</code></p>
</section>
<section id="performance-concepts" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="performance-concepts"><span class="header-section-number">4.3</span> Performance Concepts</h3>
<ul>
<li><p><strong>Memory coalescing:</strong> threads in a warp (32 threads) should access consecutive addresses to combine loads/stores into few transactions.</p>
<ul>
<li>✅ <strong>Good:</strong> <code>thread 0 → addr[0], thread 1 → addr[1], ..., thread 31 → addr[31]</code> (coalesced into 1-2 transactions)<br>
</li>
<li>❌ <strong>Bad:</strong> <code>thread 0 → addr[0], thread 1 → addr[100], thread 2 → addr[200]...</code> (32 separate transactions)</li>
</ul></li>
<li><p><strong>Warp:</strong> A group of 32 threads that execute in lockstep (SIMT - Single Instruction, Multiple Threads). Threads in a warp share the same instruction stream. Warps are the fundamental unit of execution on the GPU.</p></li>
<li><p><strong>Synchronization:</strong> <code>__syncthreads()</code> is a barrier for all threads in a block (not across blocks). Use before reading shared memory written by other threads. <strong>Important:</strong> All threads in a block must reach the barrier, or you’ll deadlock.</p></li>
<li><p><strong>Occupancy:</strong> The ratio of active warps to maximum warps per SM. Higher occupancy doesn’t always mean better performance (register pressure, shared memory limits).</p></li>
</ul>
</section>
<section id="common-patterns-best-practices" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="common-patterns-best-practices"><span class="header-section-number">4.4</span> Common Patterns &amp; Best Practices</h3>
<p>You’ll always (1) map data to threads, (2) ensure bounds checks, (3) choose grid/block sizes, and (4) verify results.</p>
<p><strong>Bounds checking pattern:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> idx <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>idx <span class="op">&gt;=</span> N<span class="op">)</span> <span class="cf">return</span><span class="op">;</span>  <span class="co">// Guard against out-of-bounds</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Block size guidelines:</strong> * Use multiples of 32 (warp size): 32, 64, 128, 256, 512, 1024 * For 2D: Common sizes are 8×8, 16×16, 32×32 * Balance: Larger blocks = more shared memory per block, but fewer blocks = less parallelism</p>
</section>
<section id="common-pitfalls" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="common-pitfalls"><span class="header-section-number">4.5</span> Common Pitfalls</h3>
<ul>
<li><strong>Forgetting bounds checks:</strong> Always check <code>if (i &gt;= rows || j &gt;= cols) return;</code> when grid size rounds up.</li>
<li><strong>Wrong indexing order:</strong> Use <code>threadIdx.x</code> for columns (fastest dimension) to enable coalescing in row-major layouts.</li>
<li><strong>Missing synchronization:</strong> If threads write then read shared memory, use <code>__syncthreads()</code> between.</li>
<li><strong>Not checking errors:</strong> Always call <code>checkCuda(cudaGetLastError())</code> after kernel launches.</li>
<li><strong>Race conditions:</strong> Multiple threads writing to the same global memory location without atomics.</li>
<li><strong>Register spilling:</strong> Too many local variables can cause register spilling to local memory (slow).</li>
</ul>
</section>
<section id="debugging-tips" class="level3" data-number="4.6">
<h3 data-number="4.6" class="anchored" data-anchor-id="debugging-tips"><span class="header-section-number">4.6</span> Debugging Tips</h3>
<ul>
<li><strong>Start small:</strong> Test with 8×8 matrices before scaling up.</li>
<li><strong>Use printf in kernels</strong> (sparingly) for small sizes: <code>if (threadIdx.x == 0 &amp;&amp; blockIdx.x == 0) printf("value: %f\n", x);</code></li>
<li><strong>Run cuda-memcheck:</strong> <code>cuda-memcheck ./your_program</code> to catch memory errors, race conditions, and invalid accesses.</li>
<li><strong>Check occupancy:</strong> Use <code>nvidia-smi</code> to monitor GPU usage, or profiling tools if available.</li>
<li><strong>Synchronize before copying:</strong> Use <code>cudaDeviceSynchronize()</code> before copying results back to host.</li>
<li><strong>Verify with small inputs:</strong> Always test correctness on small, known inputs first.</li>
</ul>
</section>
<section id="cuda-documentation-finding-functions" class="level3" data-number="4.7">
<h3 data-number="4.7" class="anchored" data-anchor-id="cuda-documentation-finding-functions"><span class="header-section-number">4.7</span> CUDA Documentation &amp; Finding Functions</h3>
<p><strong>You will need to look up CUDA functions in the official documentation.</strong> For each function you use:</p>
<ul>
<li><strong>If the function has its own page</strong> (e.g., <code>cudaMalloc</code>, <code>cudaMemcpy</code>), link directly to that page.</li>
<li><strong>If the function is part of a larger API section</strong> (e.g., vector types like <code>float4</code>), link to the relevant section of the programming guide.</li>
</ul>
<p><strong>Key Documentation Resources:</strong></p>
<ul>
<li><strong><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/">CUDA C++ Programming Guide</a></strong> - Complete reference for CUDA programming
<ul>
<li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#memory-hierarchy">Memory Hierarchy</a> - Detailed memory model</li>
<li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#built-in-variables">Built-in Variables</a> - <code>blockIdx</code>, <code>threadIdx</code>, etc.</li>
<li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#vector-types">Vector Types</a> - <code>float4</code>, <code>int4</code>, etc.</li>
<li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#synchronization-functions">Synchronization Functions</a> - <code>__syncthreads()</code>, etc.</li>
</ul></li>
<li><strong><a href="https://docs.nvidia.com/cuda/cuda-runtime-api/">CUDA Runtime API</a></strong> - Host-side functions
<ul>
<li><a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__MEMORY.html">Memory Management</a> - <code>cudaMalloc</code>, <code>cudaFree</code>, <code>cudaMemcpy</code></li>
<li><a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__DEVICE.html">Device Management</a> - <code>cudaDeviceSynchronize</code>, <code>cudaGetLastError</code></li>
</ul></li>
<li><strong><a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/">CUDA Best Practices Guide</a></strong> - Performance optimization tips</li>
</ul>
<p><strong>Example:</strong> If you use <code>cudaMalloc</code>, link to: https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g37d37965bfb4803b6d4e59ff26856356</p>
<p>If you use <code>float4</code>, link to: https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#vector-types</p>
</section>
<section id="quick-reference" class="level3" data-number="4.8">
<h3 data-number="4.8" class="anchored" data-anchor-id="quick-reference"><span class="header-section-number">4.8</span> Quick Reference</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 33%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Concept</th>
<th>Syntax</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kernel launch</td>
<td><code>kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(args)</code></td>
<td>Grid/block are <code>dim3</code></td>
</tr>
<tr class="even">
<td>Global memory alloc</td>
<td><code>cudaMalloc(&amp;ptr, size)</code></td>
<td>Returns device pointer</td>
</tr>
<tr class="odd">
<td>Copy to device</td>
<td><code>cudaMemcpy(dst, src, size, cudaMemcpyHostToDevice)</code></td>
<td></td>
</tr>
<tr class="even">
<td>Copy from device</td>
<td><code>cudaMemcpy(dst, src, size, cudaMemcpyDeviceToHost)</code></td>
<td></td>
</tr>
<tr class="odd">
<td>Shared memory</td>
<td><code>__shared__ float sdata[256]</code></td>
<td>Per-block, ~48KB limit</td>
</tr>
<tr class="even">
<td>Synchronization</td>
<td><code>__syncthreads()</code></td>
<td>Block-level barrier</td>
</tr>
<tr class="odd">
<td>Error check</td>
<td><code>checkCuda(cudaGetLastError())</code></td>
<td>After kernel launch</td>
</tr>
<tr class="even">
<td>Device sync</td>
<td><code>cudaDeviceSynchronize()</code></td>
<td>Wait for kernel completion</td>
</tr>
<tr class="odd">
<td>Vector load</td>
<td><code>float4 vec = *reinterpret_cast&lt;float4*&gt;(&amp;ptr[i])</code></td>
<td>Aligned access</td>
</tr>
<tr class="even">
<td>Vector store</td>
<td><code>*reinterpret_cast&lt;float4*&gt;(&amp;ptr[i]) = vec</code></td>
<td>Aligned access</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="task-1-welcome-to-61cuda-2d-copy-kernel-10-pts" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="task-1-welcome-to-61cuda-2d-copy-kernel-10-pts"><span class="header-section-number">5</span> Task 1 — Welcome to 61Cuda: 2D Copy Kernel (10 pts)</h2>
<section id="conceptual-overview" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="conceptual-overview"><span class="header-section-number">5.1</span> Conceptual Overview</h3>
<p>Warm up with indexing and coalesced global memory access. You’ll copy a dense matrix from device input to device output using a 2D grid of 2D blocks, one element per thread.</p>
</section>
<section id="data-flow" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="data-flow"><span class="header-section-number">5.2</span> Data Flow</h3>
<ul>
<li><strong>Input:</strong> <code>in ∈ R^{rows×cols}</code> (row‑major <code>in[r*cols + c]</code>), allocated in <strong>device</strong> memory.<br>
</li>
<li><strong>Processing:</strong> For each <code>(r,c)</code> covered by a thread, read <code>in[r,c]</code> and write it to <code>out[r,c]</code>. Use 2‑D indexing and guard against out‑of‑bounds.<br>
</li>
<li><strong>Output:</strong> <code>out ∈ R^{rows×cols}</code> identical to <code>in</code> (device memory).</li>
</ul>
</section>
<section id="your-task" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="your-task"><span class="header-section-number">5.3</span> Your Task</h3>
<p>Implement <code>copy2D_kernel</code> and the host wrapper <code>copy2D(...)</code></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"check.cuh"</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> copy2D_kernel<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> __restrict__ in<span class="op">,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span><span class="op">*</span> __restrict__ out<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rows<span class="op">,</span> <span class="dt">int</span> cols<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: compute r, c using blockIdx/threadIdx and blockDim</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: bounds check: if (r &gt;= rows || c &gt;= cols) return;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: copy one element</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> copy2D<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> d_in<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> d_out<span class="op">,</span> <span class="dt">int</span> rows<span class="op">,</span> <span class="dt">int</span> cols<span class="op">,</span> dim3 block<span class="op">){</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Suggest block = (16,16,1)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>dim3 grid<span class="op">((</span>cols <span class="op">+</span> block<span class="op">.</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">)/</span>block<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>rows <span class="op">+</span> block<span class="op">.</span>y <span class="op">-</span> <span class="dv">1</span><span class="op">)/</span>block<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>copy2D_kernel<span class="op">&lt;&lt;&lt;</span>grid<span class="op">,</span> block<span class="op">&gt;&gt;&gt;(</span>d_in<span class="op">,</span> d_out<span class="op">,</span> rows<span class="op">,</span> cols<span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>checkCuda<span class="op">(</span>cudaGetLastError<span class="op">());</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>checkCuda<span class="op">(</span>cudaDeviceSynchronize<span class="op">());</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Testing &amp; Tips</strong></p>
<ul>
<li>Prefer <code>threadIdx.x</code> to index <strong>columns</strong> to encourage coalesced row‑major accesses.<br>
</li>
<li>Run: <code>./build/cs61cuda --task=copy --M=64 --N=128 --verify</code>.</li>
</ul>
</section>
</section>
<section id="task-2-cpu-baseline-matmul-15-pts" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="task-2-cpu-baseline-matmul-15-pts"><span class="header-section-number">6</span> Task 2 — CPU Baseline Matmul (15 pts)</h2>
<section id="conceptual-overview-1" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="conceptual-overview-1"><span class="header-section-number">6.1</span> Conceptual Overview</h3>
<p>Implement a correct triple‑loop matrix multiply in row‑major order. This is the correctness oracle for later tasks.</p>
</section>
<section id="data-flow-1" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="data-flow-1"><span class="header-section-number">6.2</span> Data Flow</h3>
<ul>
<li><strong>Input:</strong> <code>A ∈ R^{M×K}</code>, <code>B ∈ R^{K×N}</code> (host memory, row‑major).<br>
</li>
<li><strong>Processing:</strong> For every <code>(i,j)</code>, compute <code>C[i,j] = Σ_{k=0..K-1} A[i,k] * B[k,j]</code>.<br>
</li>
<li><strong>Output:</strong> <code>C ∈ R^{M×N}</code> (host memory).</li>
</ul>
</section>
<section id="your-task-1" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="your-task-1"><span class="header-section-number">6.3</span> Your Task</h3>
<p>Fill <code>mm_cpu(...)</code> in <code>src/cpu_baseline.cpp</code>.</p>
<p><strong>Starter (skeleton) — <code>src/cpu_baseline.cpp</code></strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mm_cpu<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> B<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> C<span class="op">,</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">){</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: triple nested loops over i (rows of A), j (cols of B), k (shared dim)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Use row-major: A[i*K + k], B[k*N + j], C[i*N + j]</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Testing &amp; Tips</strong></p>
<ul>
<li>Use small sizes first (e.g., 8×8×8). GPU results in later tasks are compared against this function with tolerance 1e‑4.</li>
</ul>
</section>
</section>
<section id="task-3-cuda-naive-matmul-30-pts" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="task-3-cuda-naive-matmul-30-pts"><span class="header-section-number">7</span> Task 3 — CUDA Naive Matmul (30 pts)</h2>
<section id="conceptual-overview-2" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="conceptual-overview-2"><span class="header-section-number">7.1</span> Conceptual Overview</h3>
<p>Parallelize Task 2 on the GPU: map each output element <code>C[i,j]</code> to a single thread. This exposes <strong>thread‑level parallelism (TLP)</strong>; performance is often limited by memory bandwidth.</p>
</section>
<section id="data-flow-2" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="data-flow-2"><span class="header-section-number">7.2</span> Data Flow</h3>
<ul>
<li><strong>Input:</strong> <code>A ∈ R^{M×K}</code>, <code>B ∈ R^{K×N}</code> (device memory), populated from host.<br>
</li>
<li><strong>Processing:</strong> Each thread computes one output <code>C[i,j]</code> by streaming the <code>k</code> dimension.<br>
</li>
<li><strong>Output:</strong> <code>C ∈ R^{M×N}</code> (device memory), copied back to host by the driver when verifying.</li>
</ul>
</section>
<section id="your-task-2" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="your-task-2"><span class="header-section-number">7.3</span> Your Task</h3>
<p>Implement <code>mm_naive_kernel</code> and the host launcher <code>mm_naive(...)</code>.</p>
<p><strong>Starter (skeleton) — <code>src/cuda_naive.cu</code></strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"check.cuh"</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> mm_naive_kernel<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> __restrict__ A<span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> __restrict__ B<span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span><span class="op">*</span> __restrict__ C<span class="op">,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">){</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: compute i (row) and j (col) from 2D grid/block</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: bounds guard</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: accumulate over k</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mm_naive<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> dA<span class="op">,</span> <span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> dB<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> dC<span class="op">,</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> dim3 block<span class="op">){</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>dim3 grid<span class="op">((</span>N <span class="op">+</span> block<span class="op">.</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">)/</span>block<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>M <span class="op">+</span> block<span class="op">.</span>y <span class="op">-</span> <span class="dv">1</span><span class="op">)/</span>block<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>mm_naive_kernel<span class="op">&lt;&lt;&lt;</span>grid<span class="op">,</span> block<span class="op">&gt;&gt;&gt;(</span>dA<span class="op">,</span> dB<span class="op">,</span> dC<span class="op">,</span> M<span class="op">,</span> N<span class="op">,</span> K<span class="op">);</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>checkCuda<span class="op">(</span>cudaGetLastError<span class="op">());</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>checkCuda<span class="op">(</span>cudaDeviceSynchronize<span class="op">());</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Notes on memory access</strong></p>
<ul>
<li>Threads in a warp vary <code>j</code> at fixed <code>k</code>, so <code>B[k*N + j]</code> is coalesced. Accesses to <code>A[i*K + k]</code> replicate a single element per thread (cache helps).</li>
</ul>
<p><strong>Run</strong> <code>./build/cs61cuda --task=naive --M=512 --N=512 --K=512 --verify</code></p>
</section>
</section>
<section id="task-4-cuda-simd-matmul-vectorized-no-shared-memory-30-pts" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="task-4-cuda-simd-matmul-vectorized-no-shared-memory-30-pts"><span class="header-section-number">8</span> Task 4 — CUDA SIMD Matmul (Vectorized, No Shared Memory) (30 pts)</h2>
<section id="conceptual-overview-3" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="conceptual-overview-3"><span class="header-section-number">8.1</span> Conceptual Overview</h3>
<p>Augment TLP with simple <strong>data‑level parallelism (DLP)</strong>: each thread computes a short contiguous vector of outputs in a row using vector loads/stores (e.g., <code>float4</code>). No shared memory yet.</p>
</section>
<section id="data-flow-3" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="data-flow-3"><span class="header-section-number">8.2</span> Data Flow</h3>
<ul>
<li><strong>Input:</strong> <code>A ∈ R^{M×K}</code>, <code>B ∈ R^{K×N}</code> (device).<br>
</li>
<li><strong>Processing:</strong> A thread at <code>(i, j0_group)</code> produces <code>V</code> outputs <code>C[i, j0..j0+V-1]</code>. Inner loop streams over <code>k</code>, reading one scalar <code>A[i,k]</code> and a vector of <code>V</code> neighbors from row <code>B[k, :]</code>.<br>
</li>
<li><strong>Output:</strong> <code>C ∈ R^{M×N}</code> (device).</li>
</ul>
</section>
<section id="your-task-3" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="your-task-3"><span class="header-section-number">8.3</span> Your Task</h3>
<p>Implement <code>mm_simd_kernel&lt;V&gt;()</code> and its launcher. Default <code>V=4</code>; handle tails where <code>N % V ≠ 0</code>.</p>
<p><strong>Starter (skeleton) — <code>src/cuda_simd.cu</code></strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">"check.cuh"</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>template<span class="op">&lt;</span><span class="dt">int</span> V<span class="op">&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> mm_simd_kernel<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> __restrict__ A<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> __restrict__ B<span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span><span class="op">*</span> __restrict__ C<span class="op">,</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">){</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: compute i (row) and j0 (first column of this thread's vector)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: maintain acc[V] and handle aligned vs tail paths</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mm_simd<span class="op">(</span><span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> dA<span class="op">,</span> <span class="dt">const</span> <span class="dt">float</span><span class="op">*</span> dB<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> dC<span class="op">,</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> M<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">int</span> vec<span class="op">,</span> dim3 block<span class="op">){</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: call specialized kernel for vec==4, else fall back</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Run</strong> <code>./build/cs61cuda --task=simd --M=1024 --N=1024 --K=1024 --vec=4 --verify</code></p>
<p><strong>Discussion prompts</strong></p>
<ul>
<li>Why does vectorizing along columns improve coalescing for loads from <code>B</code> and stores to <code>C</code>?<br>
</li>
<li>What changes would shared‑memory tiling introduce (Task 5 EC)?</li>
</ul>
</section>
</section>
<section id="task-5-optional-performance-engineering-15-ec" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="task-5-optional-performance-engineering-15-ec"><span class="header-section-number">9</span> Task 5 — (Optional) Performance Engineering (15 EC)</h2>
<p>Make it <strong>faster</strong>. Ideas:</p>
<ul>
<li><strong>Shared‑memory tiling</strong> (classic 16×16 or 32×32 tiles).<br>
</li>
<li><strong>Register tiling</strong>: each thread computes a small <code>r×c</code> tile.<br>
</li>
<li><strong>Loop unrolling &amp; <code>#pragma unroll</code></strong> for <code>k</code>.<br>
</li>
<li><strong>Occupancy tuning</strong>: vary <code>blockDim</code> to trade registers vs parallelism.<br>
</li>
<li><strong>Mixed precision</strong>: keep FP32 accumulate but try <code>__half</code> inputs (only if you also keep a FP32 correctness path for grading).<br>
</li>
<li><strong>Software prefetch</strong>: read the next <code>k</code> slice early.</li>
</ul>
<section id="performance-targets-grading" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="performance-targets-grading"><span class="header-section-number">9.1</span> Performance Targets &amp; Grading</h3>
<p>We’ll measure performance in <strong>GFLOP/s</strong> (billions of floating-point operations per second) on a standard GPU. The formula is: <code>GFLOP/s = (2 × M × N × K) / (time_in_seconds × 1e9)</code>.</p>
<p><strong>Grading Rubric:</strong></p>
<ul>
<li><strong>Full credit (15 pts):</strong> ≥ 2.0× speedup over Task 4 baseline
<ul>
<li>Example: If Task 4 runs at 500 GFLOP/s, you need ≥ 1000 GFLOP/s</li>
<li>Must maintain correctness (within 1e-4 tolerance)</li>
<li>Must include analysis in README-perf.md</li>
</ul></li>
<li><strong>Partial credit (10 pts):</strong> 1.5× - 2.0× speedup over Task 4 baseline
<ul>
<li>Example: If Task 4 runs at 500 GFLOP/s, you need 750-1000 GFLOP/s</li>
<li>Must maintain correctness</li>
<li>Must include analysis in README-perf.md</li>
</ul></li>
<li><strong>Minimal credit (5 pts):</strong> 1.2× - 1.5× speedup over Task 4 baseline
<ul>
<li>Example: If Task 4 runs at 500 GFLOP/s, you need 600-750 GFLOP/s</li>
<li>Must maintain correctness</li>
<li>Must include analysis in README-perf.md</li>
</ul></li>
<li><strong>No credit (0 pts):</strong> &lt; 1.2× speedup, or correctness failures, or missing README-perf.md</li>
</ul>
<p><strong>Note:</strong> Baseline Task 4 performance will vary by GPU. We’ll normalize based on the reference implementation’s performance on the grading hardware. The speedup ratios above are relative to your Task 4 implementation.</p>
<p>We’ll publish a lightweight leaderboard (GFLOP/s). Please write a short <strong>README-perf.md</strong> describing: * What optimizations you tried * Why each optimization helped (or didn’t) * Performance measurements (GFLOP/s) for Task 4 baseline and your optimized version * Any insights about memory access patterns, occupancy, or other performance factors</p>
<p><strong>Command‑Line Interface (Driver)</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>cs61cuda <span class="op">--</span>task<span class="op">={</span>copy<span class="op">|</span>cpu<span class="op">|</span>naive<span class="op">|</span>simd<span class="op">}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">--</span>M<span class="op">=</span><span class="dv">1024</span> <span class="op">--</span>N<span class="op">=</span><span class="dv">1024</span> <span class="op">--</span>K<span class="op">=</span><span class="dv">1024</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">--</span>block<span class="op">=</span><span class="dv">16</span> <span class="op">--</span>vec<span class="op">=</span><span class="dv">4</span> <span class="op">--</span>repeat<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>verify</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li><code>--task=copy</code> ignores <code>K</code>.<br>
</li>
<li><code>--vec</code> controls SIMD width in Task 4; grader uses 4.<br>
</li>
<li><code>--verify</code> runs <code>mm_cpu</code> then compares results (L2 relative error ≤ 1e-4).</li>
</ul>
</section>
</section>
<section id="correctness-floatingpoint-notes" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="correctness-floatingpoint-notes"><span class="header-section-number">10</span> Correctness &amp; Floating‑Point Notes</h2>
<ul>
<li>We compare with a small absolute+relative tolerance (<code>1e-4</code>).<br>
</li>
<li>Random inputs in <code>[-1, 1]</code> with fixed seed.<br>
</li>
<li>Your GPU kernels must <strong>not</strong> read/write out of bounds; failing <code>cuda-memcheck</code> is an automatic zero for that test.</li>
</ul>
<hr>
</section>
<section id="debugging-checklist" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="debugging-checklist"><span class="header-section-number">11</span> Debugging Checklist</h2>
<ul>
<li>After each kernel launch:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cudaDeviceSynchronize<span class="op">();</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>checkCuda<span class="op">(</span>cudaGetLastError<span class="op">());</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>Use <code>printf</code> inside kernels <strong>sparingly</strong> on tiny sizes.<br>
</li>
<li>Try <code>cuda-memcheck</code> for invalid addresses / race conditions.<br>
</li>
<li>Start small (e.g., <code>M=N=K=8</code>) then scale.</li>
</ul>
</section>
<section id="style-submission" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="style-submission"><span class="header-section-number">12</span> Style &amp; Submission</h2>
<ul>
<li>Clear variable names (<code>i,j,k</code>, <code>M,N,K</code>).<br>
</li>
<li>Comments: what the mapping is, what each thread computes, any assumptions.<br>
</li>
<li>No undefined behavior (no out‑of‑bounds pointer math, no aliasing shenanigans).<br>
</li>
<li>Submit your edited <code>.cpp/.cu</code> files and <strong>README.md</strong> answering the reflection prompts below.</li>
</ul>
<section id="reflection-graded-in-task-5-rubric-even-if-you-skip-perf-ec" class="level3" data-number="12.1">
<h3 data-number="12.1" class="anchored" data-anchor-id="reflection-graded-in-task-5-rubric-even-if-you-skip-perf-ec"><span class="header-section-number">12.1</span> Reflection (graded in Task 5 rubric even if you skip perf EC)</h3>
<ol type="1">
<li>Where is your naive kernel memory‑bound? Which array dominates traffic and why?<br>
</li>
<li>Why does vectorizing along columns improve coalescing? What’s the trade‑off?<br>
</li>
<li>What would shared‑memory tiling change about the access pattern?</li>
</ol>
<hr>
</section>
</section>
<section id="reference-shapes-indexing" class="level2" data-number="13">
<h2 data-number="13" class="anchored" data-anchor-id="reference-shapes-indexing"><span class="header-section-number">13</span> Reference: Shapes &amp; Indexing</h2>
<p>Row‑major:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">:</span> MxK → A<span class="op">[</span>i<span class="op">*</span>K <span class="op">+</span> k<span class="op">]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>B<span class="op">:</span> KxN → B<span class="op">[</span>k<span class="op">*</span>N <span class="op">+</span> j<span class="op">]</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>C<span class="op">:</span> MxN → C<span class="op">[</span>i<span class="op">*</span>N <span class="op">+</span> j<span class="op">]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Grid/block formulas used throughout:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> blockDim<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="rubric-details" class="level2" data-number="14">
<h2 data-number="14" class="anchored" data-anchor-id="rubric-details"><span class="header-section-number">14</span> Rubric Details</h2>
<p><strong>Task 1 (10)</strong></p>
<ul>
<li><ol start="4" type="1">
<li>correct 2D indexing + bounds<br>
</li>
</ol></li>
<li><ol start="3" type="1">
<li>coalesced mapping (x→cols)<br>
</li>
</ol></li>
<li><ol start="3" type="1">
<li>passes tests, tidy style</li>
</ol></li>
</ul>
<p><strong>Task 2 (15)</strong></p>
<ul>
<li><ol start="10" type="1">
<li>correct triple‑loop for arbitrary M,N,K<br>
</li>
</ol></li>
<li><ol start="5" type="1">
<li>clear comments &amp; no UB</li>
</ol></li>
</ul>
<p><strong>Task 3 (30)</strong></p>
<ul>
<li><ol start="10" type="1">
<li>correct one‑element/thread mapping<br>
</li>
</ol></li>
<li><ol start="10" type="1">
<li>correct launch geometry &amp; bounds<br>
</li>
</ol></li>
<li><ol start="5" type="1">
<li>reasonable performance (scaled timing)<br>
</li>
</ol></li>
<li><ol start="5" type="1">
<li>comments explaining memory pattern</li>
</ol></li>
</ul>
<p><strong>Task 4 (30)</strong></p>
<ul>
<li><ol start="12" type="1">
<li>correct SIMD (V outputs/thread), handles tails<br>
</li>
</ol></li>
<li><ol start="8" type="1">
<li>proper vector loads/stores when aligned<br>
</li>
</ol></li>
<li><ol start="5" type="1">
<li>coalesced writes &amp; justified mapping<br>
</li>
</ol></li>
<li><ol start="5" type="1">
<li>performance better than naive on large sizes</li>
</ol></li>
</ul>
<p><strong>Task 5 EC (15)</strong></p>
<ul>
<li><ol start="10" type="1">
<li>measurable speedup over Task 4<br>
</li>
</ol></li>
<li><ol start="5" type="1">
<li>README‑perf.md analysis</li>
</ol></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>